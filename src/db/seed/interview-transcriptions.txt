[00:00.000 --> 00:01.000]  Hello?
[00:01.000 --> 00:02.000]  Hello.
[00:02.000 --> 00:03.000]  Hi.
[00:03.000 --> 00:04.000]  Hi.
[00:04.000 --> 00:05.000]  How's it going?
[00:05.000 --> 00:06.000]  Good. How are you?
[00:07.000 --> 00:08.000]  Doing good. Doing good.
[00:09.000 --> 00:10.000]  Yeah, sorry.
[00:10.000 --> 00:11.000]  I couldn't hear you for a sec. So I just wrote this on the screen there. Have you ever used the platform before?
[00:28.080 --> 00:30.080]  Yes, a couple of times.
[00:30.080 --> 00:31.080]  Okay. So then I guess you're familiar with how it all works. So then I'm just going to jump straight into a coding question.
[00:39.080 --> 00:40.080]  All right.
[00:40.080 --> 00:47.080]  So the first question is, are you familiar with the concept of order statistics? Have you heard that term before?
[00:50.080 --> 00:51.080]  No.
[00:51.080 --> 00:52.080]  Okay. It's actually a very simple thing with an overly complicated name. So given an unordered set of numbers, like what I've written here, the order statistics are like the nth element in the list if it were sorted. So like the first smallest number in this list is going to be one. And then the second smallest number is two. And then basically the order, in terms of the order, the nth order statistic is then the nth smallest. That make sense? I guess this is a bad set of numbers to have chosen. So then this makes it a little more clear.
[02:00.200 --> 02:03.200]  All right. So we're just going to have some algorithmic questions about finding some of these nth order statistics.  And just to get started with sort of a warm up problem, how about if I, if you write a function that given a list of numbers that are out of order, you just find the smallest. So basically the first order statistic.
[02:26.240 --> 02:27.240]  Okay.
[02:27.240 --> 02:28.240]  Sounds good. So I'll just declare it here.  So the static int is the return.  And then I'll just call it min.
[02:39.240 --> 02:40.240]  Yep.  And then take the int, I'll call it n.  All right.  So then here I'll...
[02:47.280 --> 02:50.280]  Yeah, this will be like an array.
[02:50.280 --> 02:51.280]  Yeah.  Okay.  So then I'll loop through the array.  And then for each of those iterations, I'll compare it against a min that I've already set up.  So I'll set the min to be a RR at zero.  And so what should I return if the array is null or if there's no values?
[03:23.320 --> 03:26.320]  Don't worry about that case.  We'll just assume it always has some values in it.
[03:31.320 --> 03:32.320]  Okay.  Sounds good.  So then we'll set the min to the first one and then going through if the...  And then we can actually start...  Okay.  Yeah.  So then going through to moving through the array, if the element at the index of i is greater...  Or sorry, less than min, then we make that the new min.  And then at the very end of the for loop, we return min.  Yep.  So just to test it to make sure, I'll write a little test here.
[04:20.360 --> 04:23.360]  Sounds good.
[04:23.360 --> 04:26.360]  Input is equal to...  Let's see.  So like 2, 3, 0, 6 should give us zero.
[04:34.360 --> 04:35.360]  Yep.  Sounds good.
[04:36.400 --> 04:37.400]  Min input.  And let's try that then.  Oh, I put it inside the for loop.  Okay.  All right.  There we go.  So it returns zero.
[04:47.400 --> 04:48.400]  Perfect.  And what's the runtime of this algorithm?
[04:51.400 --> 04:52.400]  Oh, then.
[04:52.400 --> 04:57.400]  And is there any faster way to do that?
[04:57.440 --> 05:02.440]  For an unsorted array that I know of, no.
[05:02.440 --> 05:03.440]  Correct.  Okay.  So now you definitely got the idea.  Now let's make this a little harder, a little trickier.  And how about you give me...  I'll just give you a little bit of a time.
[05:18.440 --> 05:19.440]  Okay.  So let's see.  Okay.  So for the second smallest number, then I think what we would need to do is maintain two variables and then kind of check across both of them to see like sort of like a larger min and a smaller min.  So let's see.  So then again, if you have a smaller, like sort of like a larger min and a smaller min or something like that, then you can check to see if there's a number that's smaller.  If it's smaller than both of them, then we'll put it into the smaller min.  And if it's only smaller than larger one, then we can put it into the larger min, the new larger min.  So once again, are we assuming that the array's length is 2 or greater?
[06:13.520 --> 06:14.520]  Yup.  So then I'll just call this min2 and we'll put this at the second element of the array.  And then here if the array is greater than the min, then it's the very smallest one.  So the min becomes array at 1 and then min2 becomes min, well we'll do this first.  So then min2 should be set to min and then min is set to the new minimum.  Otherwise, if the array element is less than min2, whereas it's still greater than min1, then this means that this should be set to, so then min2 becomes the new element and then instead min becomes min2.
[07:29.400 --> 07:33.720]  Min2 becomes the array, wait but what happened to min then?
[07:34.680 --> 07:37.640]  Oh sorry, yeah this is maintain the same I think.  Yeah because if it's less than min2 then min1 is still the smallest so then that should stay the same but min2 gets updated.
[07:48.760 --> 07:50.680]  Okay yeah let's run this.  Oh I have to return min2 this time.  Okay so this one should give me three, oh sorry it should give me two, okay there give me two.
[08:03.240 --> 08:03.960]  Yeah perfect.  Okay, yeah interesting I'm trying to think if there is, I'm trying to see if there's a corner case here with the fact does it, does min2, what if, yeah I guess, what if these were the numbers here?  Let's try those out, so it should actually be three because three is the second smallest.
[08:57.400 --> 08:58.840]  Yeah some of them are three.
[09:00.680 --> 09:11.160]  And so min2 gets set to, I guess I'm just looking at this, oh what if, what if there were two?  Oh because you start back at zero again and then you flip it all around, I got it.  Okay yeah perfect.  Okay and what's the runtime of this one?
[09:29.000 --> 09:30.600]  This one is still open.
[09:31.320 --> 09:36.360]  Okay so let's just say that we're, as you might have guessed, we're going to want to move this and turn it into n.  So we're going to want to add another parameter here that says I want to find the nth smallest.  Now one way you could do it is you could just expand on this idea and you could just create sort of a list of all of the min's up to n.
[10:10.840 --> 10:11.340]  Right.
[10:12.040 --> 10:16.120]  Now what would the runtime of that algorithm be?
[10:16.120 --> 10:22.040]  Well if we're storing them all then we need to check across each of them each time.  So the runtime would become n squared since we're running through all of the previous values every time we go through the array.
[10:31.160 --> 10:41.400]  Yep okay so the first, so to get the zero if, or yeah the first it just took o of one or o of n to get two to go of n but now if you expand this in that same sort of pattern it actually becomes o of n squared.  So is there a way that you can improve on that o of n squared time?
[10:55.800 --> 10:56.760]  All right let's see.  So maybe there's a way where since, oh actually yeah I think one way to improve would just be to sort the array and then that would make it n log n immediately and then all we have to do is find the nth index in the sorted array.
[11:17.800 --> 11:20.040]  Yep okay perfect.  Now here's the real challenge.  Can we do better than n log n for any arbitrary, actually I guess I gave this the wrong the wrong letter, for any arbitrary m that we're trying to find.  So we saw that when m is one we can do it in n time when m is two we can still do it in n time.  Do you think that there's a way that you could extrapolate on that sort of pattern and say oh I can just always do it in n time no matter which one of these I'm trying to find?
[12:09.320 --> 12:09.560]  Right.  So the reason why we could do it in o of n time for if n equals one is because we could just go through and compare them all and see whichever one is the smallest and then for n equals two we had to compare it with each of them and also the previous minimum.  So without having to compare it to all of the previous minimums I'm trying to think if there's a way to figure out the nth smallest.  Maybe if we delete certain objects but then that wouldn't help either because if we go through.
[13:08.520 --> 13:10.040]  But if you did if you delete.  So it certainly it's tricky so if if you get stuck I have some have some hints for you.
[13:39.960 --> 13:41.560]  Yes I would appreciate a hint.
[13:42.520 --> 13:58.200]  Okay so what so you mentioned the the n log n case of sorting and and then just picking the the nth item in the in the list.  So in that sense you know once we sort this input when you have two three five six and then let's say your m is is three and basically you just go straight to the five right and you know that five is in the correct place and that it is that everything to the left is below it and everything to the right is above it and it's in position number three so that means so that means it's necessarily correct.  Now what you've also done and actually if we if we expand this out just a little bit more then I guess I can just do this and what you can see is 10 15 and 21 so you had that this number five is in the correct position but also every single other number is also in the correct position so you've also done work to make sure that the three is in the second position and the two is in the first position and the ten is in the fifth position and you put them all in the right places even though at the end of the day all you really cared about was that that five was in the right place because whatever order any of these other ones are in it doesn't really matter you don't really care because you're only interested in this one.
[15:46.360 --> 15:58.360]  Right okay um that's interesting so basically
  we're looking for a way to ensure that a certain value is in a certain spot but all the other
  values don't have to be sorted.
[16:05.720 --> 16:12.520]  Correct.
[16:05.720 --> 16:12.520]  And the one that we want to be in the right place is at the values don't have to be sorted. Correct. And the one that we want to be in the right place is at the M index.
[16:12.520 --> 16:27.160]  Right.
[16:12.520 --> 16:27.160]  Um so if we did this for the first minimum then basically we would have to go through each of the elements and then put all the ones that are larger than a certain minimum to the right of it so that it would be at the beginning so basically we would have to go through and figure out um like how many numbers are lower than that number and how many numbers are larger than that number so what if we do that then um is it like maybe there's some way that we can balance so say we want M to be um two like in this case where the index is two that means that we want two numbers to be less than the one at M and then four numbers to be to the right so then maybe we can sort of like choose um somehow there should be a way where we can go through and figure out and make it balanced so that it's like um equal on both sides even though those aren't sorted.  But we would need to know what the number five already is in order to go through and actually put that in its right spot so there needs to be a way where we can figure that out without knowing five.
[17:34.760 --> 17:35.240]  Right.
[17:44.360 --> 17:49.800]  Yeah and if we just chose a random number or went one by one like we did here then it wouldn't work because then we would still go back to being N square we just still have to go through all the numbers to see which one was right.
[17:54.280 --> 17:57.960]  Right.
[18:01.960 --> 18:07.800]  But let's let's take a look at that that example that that um you you had just said that um you just talked about saying um you you kind of described this process where you take this input array you take the first number that you found and you made sure that it went in the right spot.  Right. So you you you described a a process of saying take this number three and put it that just that one number where it goes so that everything to the left is less than it and everything to the right is greater than it. What was that?
[18:39.400 --> 18:46.120]  A binary search tree.
[18:47.400 --> 18:55.000]  Um yeah I mean so there's that that's that's kind of a part of it but so so describe how you might how you might do that. How would you find so just given I mean you don't really have much information about this um this array coming into it because it's unsorted it could be in any order so you might as well just start with the first number you find and say I'm just going to find I'm just going to put that first one where it belongs and then I'll tackle the rest of the problem after that. So you know for example you can think of what it would look like afterwards would be um 21 and 15. So you can imagine that this might be what the array would look like after you found the the first place. So so three goes in this spot and everything to the left is less than three and everything to the right is greater than three and you still don't really know about what's what's going on on either side and you haven't really sorted it altogether but you do know that three is in the right spot.  So does this then give you some additional information in terms of now trying to like where would you proceed from here? So so keep in mind that like we're still looking for the third largest number and you've just figured out that the number three goes in position number one.
[20:31.880 --> 20:36.760]  So then I know that the number three is the second largest number and at this point I would have enough information to find the third largest number using the technique that I just did before where if I know the previous minimum then I just have to run through the array one more time to find the next minimum.
[20:45.560 --> 20:58.280]  Right that's true but in the and and what which part of that array would you run that algorithm on the whole thing or a part of it?  The right because the right is the part that's unsorted. 
[21:07.560 --> 21:16.680]  Right well actually in a sense the left is also unsorted kind of because we don't really have any any guarantees about what's going on to the to the left. I mean in this case in this case you do because there's only one element so there's not really much sorting to do but but what what else is is an interesting property so now that you have this three that's in the right spot what do you know about like in terms of what you're looking for are you interested in anything on the left or you interested on anything on the right or you interested in both sides?
[21:46.600 --> 21:53.880]  Well right now looking at this array I would be interested in the right since this the three is only an element at index one but what we're looking for is index three.  But in terms of ordering what we're looking for and since but the two could be the five too like what if this what if there was a five here instead of the two but then 
[22:19.160 --> 22:26.280]  Yeah it couldn't be it couldn't be because you've already you've you've sort of you've split this this array up maybe I wasn't clear in exactly the the the thing that I did but if I let me let me start by just kind of like rearranging this a little bit more and making it kind of a little more random and then and then sort of I'll do I'll I'll do it again so so given and I guess you've been talking about sort of M yeah well okay we just keep this the way the way it is but so so you you start with this 10 and you first make sure that everything on your left is less than 10 and everything on your right is greater than 10 so this might look like this two five six three ten fifteen eleven so you've just kind of you've shifted things around but you've shifted them around and in a way so that everything on the left is less than 10 and everything on the right is greater than 10 so it's not just that you found that the one right place for it but you've done a little bit extra to okay to make sure that you've sort of you've split the array in two pieces
[23:57.240 --> 24:05.480]  Yeah so then this is actually pretty helpful because if the 10 is over here and this is in the one zero one two three fourth index and we know that M has to be to the left of it so we don't really need to worry to the right anymore because those are greater than 10 anyway
[24:17.560 --> 24:29.480]  Exactly so so then when you when you repeat this and you you sort of go for another iteration of it you're only going to be looking at the left side right yeah yeah okay so does that give you some ideas about how how this might how this algorithm might might work 
[24:38.920 --> 24:49.080]  Yeah it does um yeah because then in the first time around i'm iterating through all the numbers to find where it belongs and then the second time around i'm only iterating through the left side so this kind of reminds me a little bit of like binary search so maybe the run times will also get a little bit better than and squared when we do it this way okay all right so i'll should i start implementing it then 
[25:07.000 --> 25:15.400] Yeah let's see let's see what happens all right
[25:21.800 --> 25:32.120] So we're outputting just the number this time again okay and this is the nth smallest okay so first what we have to do is um well i'm just going to write the code for the first time and then we can probably iterate through and make that repeat so the first time around i'll have to go through the entire array so the first time around i'll have to go through the entire array and then um so i'll have to select so if i look at the first one i'll have to put it in the right spot so then i'll take um i'll take sort of like index to be placed um i'll just call it index um is let's say i or actually yeah if we make it zero actually before the array before this loop then we're looking for so this looks at um we're going through them and then if we say that if the item at that index is less than or if it's greater than whatever is there then we need to move it to the right so kind of like swap it um yeah so if the array at the next is greater than array at i then we need to do some swapping here so just to make things should i just kind of abbreviate it and just write swap here or do you want me to write the whole swap um you can just
[27:30.120 --> 27:35.720]  Write swap that's fine okay and then well actually i'm going to need to test it later so i might as well just do it now never mind um so then we'll write in temp as array at i i and the array at i look to array index and array index is equal to 10 so this switches them around if it's greater than um but if it's less than then essentially we need to um well we we just need to keep moving actually so we don't need to do anything there um but if they're equal to each other then we stop yeah so if the array index is greater than wait did i do this right let's see so we start with index equals zero and if it's greater than oh okay there's a problem here because if it's starting with the first one then it'll just stop immediately since it's equal to the same one um so then we'll start at the first here yeah so then if um okay so if we start with the first one then the first so index is equal to zero um and the first element is 10 and then it checks to see at array at one which is two and 10 is greater than two so then it swaps and now it's two and then 10 and then it compares it again five uh 10 is greater than five so it swaps six six is greater than five so it swaps and then it looks at 11 and they are okay so this breaks now because it'll stop since it's greater than um but it needs to continue and look for that three 
[29:45.160 --> 29:50.600]  Wait it wouldn't rate so those two numbers don't equal each oh so that's wait yeah so yeah so it wouldn't stop but
[30:05.640 --> 30:14.360]  It still needs to um well yeah so okay never mind yeah it would stay there and then it would go through and then check again three and then now that it's less than three it'll swap with that one instead and then 10 will be um where the three was and then it'll check again 15 it's greater than um so it'll stay there and that puts it uh wait but that's not right oh wait so that would that would actually work for this specific input but think about what would happen if the input was something like this so you know you you first swap the 10 with the two so that's right and then you swap the 10 with a five which is which is totally right and then you stop the 10 with the six then you leave that then you swap the three with the 10 so that's cool and then you swap the zero with the 10
[31:24.200 --> 31:31.320]  Yeah that's not that's not right quite
[31:24.200 --> 31:31.320]  Right because when you skipped over the 11 now you have something on the left that is bigger than it should be so then i think maybe we have to move the 11 along with the 10 now every time um so maybe we can swap the 11 with whatever's next to it so that it keeps like sort of moving away
[31:54.360 --> 31:57.400]  right
[32:00.760 --> 32:06.600]  to swap the 11 so so you had this point where you had the 10 and the zero is like this but then then what were you going to do no it's one you know in the 11
[32:08.200 --> 32:18.680]  no it's yeah yeah no it's like the 10 was here what was here before you got three yeah and then you would check the 10 and the 11 and then since 11 is great you could swap it away so that it goes to yeah you could actually just swap it with like the end of the array so then this becomes zero and this becomes 11 and then here we check against the zero it's greater than and then it swaps and then you check the 10 and the three it's greater so it's okay and that's the right place 
[32:52.200 --> 33:01.320]  So then presumably if there was another number that was greater than 10 you would swap it so like um so we had it here that was like uh 10 11 so we're sort of looking at the 10 now um the three and we had a 15
[33:29.800 --> 33:33.080]  So then it would first compare the 10 and the 11 and then it would okay now i see what you're saying then once if it swaps there it will just skip over and it wouldn't work though
[33:42.840 --> 33:48.920]  so but but you have me on the right track like this is this is definitely the kind of of uh sort of manipulating that you're that you're going to want to be doing in this um in this array so um and and definitely the like you're definitely on the right track with respect to looking at you know when when you started with this number 10 and you're looking at each one of these numbers as you're going uh as you're going up and as long as it's left then then you know you're you're sort of keeping it to the left and as long as it's greater than you're keeping it to the right so that's kind of it's kind of how you're sort of scanning this list of numbers so can you think of a way and and yet so you you hit into this one sort of problematic case that when you start to have multiple numbers that are bigger then it gets kind of tough with how do you deal with the um how do you deal with the sort of bookkeeping of where where does it go who can you swap it with
[34:55.960 --> 35:03.640]  yeah well i can think of one way to solve that which would be to just create another array and then if it's less than the number we want we put it into the beginning of the array and hold two sort of like counters for where the beginning of the arrays and then where the end of the arrays and then if the number is larger we add it to the end until there's only one spot left and then that's where the tens have to go
[35:19.240 --> 35:25.240] That's a good way to do it
[35:19.240 --> 35:25.240] All right so then i'll try to implement that instead i'll just erase this okay so then we have now two counters so int start is equal to zero and int end is equal to the array dot length and then we loop through um and so we know the number that we're looking for so i'll just um yeah i'll put that in as uh yeah actually yeah i'll just put that in as index again and then that'll start at zero this time um and then so basically if the number that we're looking at that we're looking at is zero then then so basically if the number that we're looking at that we're looking at right now which is array at i is less than the array at index then we put it to the right so then we have this new array that i have to create and it's the same length um and then if the array at i is less than the array index then it should go in the beginning so then it does um int at start oh sorry uh what did i call it new array new array at start becomes array at index and then we have to do start plus plus to show that we've added an element and then if the array at i Wait sorry 
[37:22.680 --> 37:30.680]  Is it uh so so in this line here uh you set array it's the new array at start is array at index uh is it index or is it i
[37:30.680 --> 37:42.120]  Oh sorry yeah i think it's a different name okay um and then are there going to be duplicates in this array or no 
[37:42.120 --> 37:47.880]  Let's just say no for now okay 
[37:47.880 --> 37:52.680]  So if there's no duplicates then any other element we look at cannot be the one that we're searching for so then we can just do an else here and then this basically says that the array at i is now greater than what we're looking for so we need to go to the right so then it goes to new array at end is equal to um the array at index yeah uh wait no i oh i made the same mistake okay and then um do n minus minus and then this loop has to this has to end whenever um start and end are one apart from each other because then that means that we found we have found our index found our index then i would do an extra so if start minus or end minus start is equal to one then we return start plus one all right so i think this should work for just for the first one to place it in the right spot so let's try it.
[38:58.440 --> 39:05.240]  Um so a couple oh i see so this is going to be sort of a so i see you're like returning the number right away but i i'm wondering so this this is going to return not the nth smallest but this is going to return some smallest that the you're basically going to return wait actually the index you're returning which position the first element will have gone to
[39:34.760 --> 39:43.080]  Yeah yeah i just wanted to break down the problem so i want to see got it okay okay so in this this is a ring um i'm not actually sure where this tends to be
[39:52.920 --> 40:01.640]  So two three five six so it's gonna be four 
[40:01.640 --> 40:08.200]  Okay so yeah it's not 
[40:12.200 --> 40:17.240]  you don't even use them so oh 
[40:12.200 --> 40:17.240]  I need to make some things
[40:20.600 --> 40:24.360]  Here's an interesting question so when will end minus start equal one One and what so uh this line here number 42 when when will this be true
[40:34.120 --> 40:39.080]  Um end minus start will be one when we've gone through all the elements of the array and now we're looking at that one empty space where the element should go okay 
[40:39.080 --> 40:47.240]  So if that's going to happen once you're already completed with this array is it is this ever going to be seen
[40:52.600 --> 40:54.600]  Oh yeah you're right You can just return after the loop and then you can return start 
[40:54.600 --> 41:11.560]  Index out of bounds
[41:13.160 --> 41:16.600]  uh oh it has to be that one
[41:23.160 --> 41:35.400]  zero one two three four i think actually um because you incremented start right here you don't need increment start there i think that's what 
[41:39.320 --> 41:49.160]  yeah all right and let me try it with another just to make sure so now if we deleted one of these then it should become it should become three i believe yeah okay all right so now i have the functionality for figuring out the spot where one specific element should go but i have to repeat until i find wherever the element at the mth index is so essentially this um this whole start if start is m then we know that we found our element right um but but the thing is this index um has to change every time so i'm thinking maybe we can sort of do this like a binary search where we choose like the middle um like the middle number in each half and then we try to put that where it belongs and then if um and then if m is greater than the index there then we run it on the right half and if m is less than then we can run it on the left half 
[42:55.400 --> 43:03.400]  Sounds good 
[42:55.400 --> 43:03.400]  okay so then here we'll start with instead of zero we'll do start plus and divided by two here okay and then um it's the 
[43:08.200 --> 43:18.040]  so then looking at the end so the the index is is representative of the number of the index of the number you're comparing everything with right yeah so in that sense you know index represented this number 10 here um is it does it get you anything to pick the number in the middle like this this number here is the number in the middle um does that one really i mean does it really matter whether i mean remember this is an unsorted array um does it really matter that you take index zero or you take index start plus end over two no it's not going to really be that it's um it's going to be 50 50 right it's not going to be exactly in the middle there and there's kind of no way to tell where um like how well this number that you're picking at random is going to split this array into so i mean you can you can you can do that but um i think starting with index zero is is a totally reasonable way to go because at this point you know it's it's just a random array there's no order so you might as well just pick any anything and um and then um go from there 
[44:34.600 --> 44:48.040]  Yeah yeah i think that's fine we can use zero then um yeah and then i think we can actually make this recursive to maybe do a little less work where once we find where the um the spot that index should go then we'll determine whether m is on the right or left and then we can do again do it but actually that might be more yeah i think that might be one way of implementing it because then we can always keep index as zero because then the array that we're looking at is now um like a sub array so the index will always be zero or we could do this just have index at start and then um loop through and then kind of just keep doing it with a new start and end that would be another way of doing um so yeah or we can just like make new parameters here for start and end and then implement it as recursive so there's like multiple ways that this could go 
[45:43.480 --> 45:49.080]  so i like your recursive idea because it's definitely going to make the code a little bit simpler um do you actually need to add more parameters here if you do it as a um as a recursive algorithm 
[45:58.120 --> 46:07.560]  no i don't have to if i change the array then i don't have to um yeah i'm just wondering like that would still take up more memory because technically uh like i would have to somehow cut off the array um going too far into it so um we'll just use it like this in the outside we turned it into a sub array okay so then um where are we okay so we're we're using index zero and then at the end of this we're returning start which ends up being the index of whatever element is at zero we need to do is determine if m is greater than or less than start so if m is greater than start um let me know we need to redo this on the right side of the array so then we should perform and palace on um i actually forgot the method for sub arrays in java 
[47:04.520 --> 47:17.480]  I think yeah i'm just looking on the uh uh i think there's a thing called range no subset fill um um substitute subsequent copy of range i mean you could just use copy of range if you wanted to it's not that bad okay so um it's 
[47:39.960 --> 47:53.560]  It looks like yeah there's like a code completion on here and it says that it's a method so i'll just use that then so copy of okay yeah so then the original would be arr and then from uh i'm assuming that the from is inclusive so then we would use uh start plus one because start we've already looked at and that's the one that's um that we found and then uh and then the end would just still be end and then we can delete that and then here would be the other way around so if we have n smallest then it would be array and then instead of start plus one this would be zero and this would be just start and then um else that means that m is equal to start which means that we found the element at the index that we want so we just return start
[48:50.280 --> 49:00.680]  Okay nice now n smallest actually takes two parameters oh right so then and i just need to add in is it m because that's relative to the entire uh the entire
[49:06.200 --> 49:14.920]  right it would so for right so if the um so if the m that we're looking for is greater than start then it would need to be m minus start and then it's element that we're looking for is uh oh wait i messed this up so if m is less than start um then now we're looking for still m um yeah okay um so now looks like all right i'm going to test this now to see if there's any issues
[49:55.400 --> 50:02.440]  okay let's just see if we give zero as m then we should still get back 10 so 
[50:02.440 --> 50:09.080]  let's just see if i was getting three so three is the smallest uh three is the is the the smallest one 
[50:09.080 --> 50:18.760]  oh yeah yeah so then it should give back okay um we need to import is this
[50:19.640 --> 50:30.920]  is a raise uh java util oh it's java util uh oh uh the lowercase c oh okay
[50:33.240 --> 50:41.640]  okay all right let's see what happens now oh i'm missing a return statement
[50:42.840 --> 50:46.040]  uh because you're uh you don't have return in in these ones wait which one are they looking at 
[50:49.800 --> 50:56.760]  uh so 52 and 54 you're not you're just calculating it without returning it got it
[51:05.880 --> 51:14.040]  all right now it's giving me zero which that wasn't even in the input array so where's the index so oh that's still not right all right let's see
[51:39.320 --> 51:46.280]  so definitely the logic looks right i'm guessing there must be some kind of off by one bug so we we already figured out that with this list when you go the first time start equals oh yeah wait start was um was three before so it should have put it in the uh so maybe there's some need to do some debugging with the with some print statements to see because yeah definitely the the logic here is looking solid
[52:39.320 --> 52:43.960]  maybe here i'll just print out a new array okay so the new array the first time oh i think it's because uh no that's not it so five six three fifteen eleven ten 
[53:14.760 --> 53:23.960]  interesting that you have the ten in there um so in that sense i think you want your your new array to be one element smaller so if you see what's happening here is that you started with index zero and then you're also checking index zero again and really your um the size is still the same so you're still checking index zero and really yeah your um the size is going to be one less because you're kind of taking one out right and then sort of partitioning it um after you've taken that one out so then yeah so then now there might be um yeah so now now that you've like reduced the size by a little bit now now you have to make up for that in when you make this copy
[54:25.560 --> 54:32.920]  well that wouldn't be affected by the new array would it because the new array oh well see so now
[54:32.920 --> 54:40.600]  the end actually has to be a ray of length minus two so right you have to you have to start the because the end is actually the end of new array dot length minus one if that makes sense
[54:53.560 --> 55:01.080]  right well it's the initial array minus one so it's like the ending but then in a new array um it's not um
[55:04.280 --> 55:14.840]  so in the new array so so i mean you you're you're placing these um you're placing these these you're copying these values over into the new array so the new array has to
[55:25.320 --> 55:29.480]  yeah all i had to do was repeat this array dot length here because the end is not actually the end it's just start to true 
[55:30.040 --> 55:37.320]  but what i'm looking at i'm looking at at 38 here oh yeah so that end is actually the end of new array dot length minus one which is array the original array dot length minus one which is array the original array of length minus two oh okay and then in this one you're not actually copying the original array you want to copy the new array because the original array is like totally out of order right and the new array is the one that is currently being copied yeah and and also you'll need the new array dot length
[56:26.440 --> 56:33.480]  oh okay i get it and new array has to be smaller yeah wait why did yeah it should be one smaller right because it's it's not including the pen itself like the number it's looking right
[56:45.480 --> 56:51.080]  So, in this one, you want to just copy to newArray.length.
[56:51.080 --> 56:52.080]  Ah.  Well, newArray.length would include the values above it, wouldn't it?
[56:59.880 --> 57:03.000]  Well, newArray.length is the end.  It's the end of the new array.  And you're trying to copy, like, from your position all the way to the end.
[57:10.680 --> 57:11.680]  Oh, yeah.  Yeah.  Okay.  So, then here, there's still something wrong with the size of newArray.
[57:22.880 --> 57:23.880]  Wait.  Wait, can you try writing again?  What's wrong with the size of newArray?  No, 46.  NewArray.  Oh, no, this one here.  Wait, you had just changed it.  38.  Oh, I'm sorry.  Yeah.
[57:44.280 --> 57:46.880]  So, this should be at minus 2.
[57:46.880 --> 57:47.880]  Yeah.  Or you could also just set end underneath the new array.  Or you could move this one up and just say end is newArray.length minus 1.  Either way, it's the same number.
[57:59.280 --> 58:00.280]  Oh, okay.  And then this shouldn't be...  Yeah, okay, and this is still arr.length minus 1, since it's one smaller.  Okay, now 3.  Okay, yeah, that's actually right.
[58:14.680 --> 58:16.280]  There it is.  Not bad.
[58:18.080 --> 58:18.880]  Here we go.  And let's try it.  I think we can do numbers too.  So, if we try to like 1, then that should give us 5.
[58:29.680 --> 58:30.680]  Aw.  No.  Close.
[58:36.080 --> 58:37.280]  All right.
[58:37.280 --> 58:39.680]  Yeah, I think there must be...  I'm guessing there's like an off by 1.  My guess is there's off by 1 either in this m minus start or this m here or the 0 to start.  I'm guessing there's like a tiny little off by 1 bug in there somewhere, which is not a big deal.  Just because we're running a little bit short on time.  So, you definitely...  You did all this work and now you're inspecting less and smaller and smaller pieces of the array as you recurse into it.  What is the runtime of this algorithm?
[59:14.480 --> 59:15.480]  Okay.
[59:15.480 --> 59:23.680]  So, the question is that you did all this work and or there's always extra code to like be careful not to do any more work than you need to.  So, the question is, has this actually sped it up or is it still nlogin or is it even greater than nlogin?
[59:36.680 --> 59:46.280]  Well, I think it depends on the case because say for example, if this array was like sorted in backwards order maybe, then basically the first one that was living with that would be case with the n and then we go back to the start and then the first one would be case with the end again and then say our n was 0, then we'd have to keep going through that array over and over.  And so, we'd basically be looking at the entire random sequence, 1, 2, 3, 4, 5, 6, so it'd be 6 plus 5 plus 4 plus 3 plus 2 plus 1, which in the end still comes out to O of n squared.  So, I think in the worst case, our new algorithm is still O of n squared.
[01:00:22.080 --> 01:00:23.080]  Okay.  But what about in say the average case?  Like what if, you know, for example, you randomized like that's sort of a common thing that people do with these kinds of divide and conquer algorithms is that if there is kind of a like a poisonous input, then you just kind of randomize it to make sure that it's that there's no that it's just going to be kind of in this big old jumbled order.  So, what can we expect sort of on the average case?  You're totally right.  There is a there's a worst case input that makes it n squared.  But what can we generally expect this to be in the average case?
[01:01:15.840 --> 01:01:22.680]  I think this is no n log n then because we're looking at the first time.  Wait, actually.  Well, the first time so in the average case, it would be like we're looking at half the array since then it wouldn't be too much and it would be too little.  So, the first time and then wait, no, we're moving at half.  So, then actually, we look at six and then three and then one, which is like n log n, I would say.
[01:01:56.560 --> 01:01:58.360]  Close.  So, can you see me typing among the n smallest?  So, so the first time you run through this in the first iteration, you have n elements that you're going over.  And then, like you said, you break it down by half.  And then the next time you just go over the n over 2, right?  And then the next one is n over 4 and n over 8, etc.  So what is that going to add up to?
[01:02:34.840 --> 01:02:37.640]  Log n.
[01:02:37.640 --> 01:02:39.640]  Is it?
[01:02:39.640 --> 01:02:45.240]  Oh no, it's just n.
[01:02:45.240 --> 01:02:47.240]  Right.
[01:02:47.240 --> 01:02:49.640]  Yeah, it becomes n.  Oh, OK.  Yeah.
[01:02:53.040 --> 01:02:53.840]  So you did it.  You got it.  You got it down from n log n to n.  And the trick is that when you do the sorts, you have this having that you do each time, but you keep doing more and more work.  So n over 4 plus 8 times n over 8.
[01:03:21.840 --> 01:03:26.640]  Plus n over 1, which is one increase in the sorting.
[01:03:26.640 --> 01:03:27.040]  Yeah.  So when you do a sort, you split it in half, and then you do both sides.  And so even though it's getting smaller and smaller, you have more and more of them that you have to kind of deal with.  And so the length of this is log n.  So the number of iterations is log n.  And so then that's why it becomes n log n.  But in your case, you don't have this ever increasing coefficient in front of it.  And so it just adds up to 2n.  And it's bounded.  So you got it.
[01:04:16.040 --> 01:04:17.640]  Very good.  All right.
[01:04:18.440 --> 01:04:18.840]  Thank you.  This is a really interesting problem.
[01:04:21.040 --> 01:04:21.440]  Yeah.  I'm glad you liked it.  Yeah.  So I'll leave some comments and stuff on the platform.  But just before we go, if you have any questions for me about interviewing or anything else, I'd be happy to answer them.
[01:04:39.040 --> 01:04:40.240]  I think I'm all set.  I'll just leave the feedback when it comes through.
[01:04:43.640 --> 01:04:44.240]  OK.  Awesome.  Then you have a good night.  And good luck with all of your future practice rounds.
[01:04:50.040 --> 01:04:51.240]  Thank you.  Have a good night.  OK.
[01:04:52.840 --> 01:04:54.240]  Bye-bye.